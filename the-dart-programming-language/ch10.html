
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Language Tour · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch11.html" />
    
    
    <link rel="prev" href="ch09.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../kia/readme.html">
            
                <a href="../kia/readme.html">
            
                    
                    Kotlin实战
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../kia/ch01.html">
            
                <a href="../kia/ch01.html">
            
                    
                    1.Kotlin:定义和目的
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../kia/ch02.html">
            
                <a href="../kia/ch02.html">
            
                    
                    2.Kotlin基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../kia/ch03.html">
            
                <a href="../kia/ch03.html">
            
                    
                    3.函数的定义和调用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../kia/ch04.html">
            
                <a href="../kia/ch04.html">
            
                    
                    4.类、对象和接口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../kia/ch05.html">
            
                <a href="../kia/ch05.html">
            
                    
                    5.Lambda编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../kia/ch06.html">
            
                <a href="../kia/ch06.html">
            
                    
                    6.Kotlin的类型系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../kia/ch07.html">
            
                <a href="../kia/ch07.html">
            
                    
                    7.运算符重载及其他约定
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../kia/ch08.html">
            
                <a href="../kia/ch08.html">
            
                    
                    8.高阶函数:Lambda作为形参和返回值
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../kia/ch09.html">
            
                <a href="../kia/ch09.html">
            
                    
                    9.泛型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../kia/ch10.html">
            
                <a href="../kia/ch10.html">
            
                    
                    10.注解与反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="../kia/ch11.html">
            
                <a href="../kia/ch11.html">
            
                    
                    11.DSL构建
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../jcip/readme.html">
            
                <a href="../jcip/readme.html">
            
                    
                    Java并发编程实战
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../jcip/ch01.html">
            
                <a href="../jcip/ch01.html">
            
                    
                    1.简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../jcip/ch02.html">
            
                <a href="../jcip/ch02.html">
            
                    
                    2.线程安全性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../jcip/ch03.html">
            
                <a href="../jcip/ch03.html">
            
                    
                    3.对象的共享
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../jcip/ch04.html">
            
                <a href="../jcip/ch04.html">
            
                    
                    4.对象的组合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../jcip/ch05.html">
            
                <a href="../jcip/ch05.html">
            
                    
                    5.基础构建模块
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../jcip/ch06.html">
            
                <a href="../jcip/ch06.html">
            
                    
                    6.任务执行
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../jcip/ch07.html">
            
                <a href="../jcip/ch07.html">
            
                    
                    7.取消和关闭
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../jcip/ch08.html">
            
                <a href="../jcip/ch08.html">
            
                    
                    8.线程池的使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../jcip/ch09.html">
            
                <a href="../jcip/ch09.html">
            
                    
                    9.图形用户界面程序
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../jcip/ch10.html">
            
                <a href="../jcip/ch10.html">
            
                    
                    10.避免活跃性危险
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../jcip/ch11.html">
            
                <a href="../jcip/ch11.html">
            
                    
                    11.性能与可伸缩性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../jcip/ch12.html">
            
                <a href="../jcip/ch12.html">
            
                    
                    12.并发程序的测试
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../jcip/ch13.html">
            
                <a href="../jcip/ch13.html">
            
                    
                    13.显式锁
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.14" data-path="../jcip/ch14.html">
            
                <a href="../jcip/ch14.html">
            
                    
                    14.构建自定义的同步工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.15" data-path="../jcip/ch15.html">
            
                <a href="../jcip/ch15.html">
            
                    
                    15.原子变量与非阻塞同步机制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.16" data-path="../jcip/ch16.html">
            
                <a href="../jcip/ch16.html">
            
                    
                    16.Java内存模型
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../the-art-of-java-concurrency-programming/readme.html">
            
                <a href="../the-art-of-java-concurrency-programming/readme.html">
            
                    
                    Java并发编程的艺术
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../the-art-of-java-concurrency-programming/ch01.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch01.html">
            
                    
                    1.并发编程的挑战
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../the-art-of-java-concurrency-programming/ch02.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch02.html">
            
                    
                    2.Java并发机制的底层实现原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../the-art-of-java-concurrency-programming/ch03.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch03.html">
            
                    
                    3.Java内存模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../the-art-of-java-concurrency-programming/ch04.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch04.html">
            
                    
                    4.Java并发编程基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../the-art-of-java-concurrency-programming/ch05.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch05.html">
            
                    
                    5.Java中的锁
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../the-art-of-java-concurrency-programming/ch06.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch06.html">
            
                    
                    6.Java并发容器和框架
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../the-art-of-java-concurrency-programming/ch07.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch07.html">
            
                    
                    7.Java中的13个原子操作类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../the-art-of-java-concurrency-programming/ch08.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch08.html">
            
                    
                    8.Java中的并发工具类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../the-art-of-java-concurrency-programming/ch09.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch09.html">
            
                    
                    9.Java中的线程池
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../the-art-of-java-concurrency-programming/ch10.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch10.html">
            
                    
                    10.Executor框架
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.11" data-path="../the-art-of-java-concurrency-programming/ch11.html">
            
                <a href="../the-art-of-java-concurrency-programming/ch11.html">
            
                    
                    11.Java并发编程实践
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../effective-java/readme.html">
            
                <a href="../effective-java/readme.html">
            
                    
                    EffectiveJava
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../effective-java/ch01.html">
            
                <a href="../effective-java/ch01.html">
            
                    
                    1.引言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../effective-java/ch02.html">
            
                <a href="../effective-java/ch02.html">
            
                    
                    2.创建和销毁对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../effective-java/ch03.html">
            
                <a href="../effective-java/ch03.html">
            
                    
                    3.对于所有对象都通用的方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../effective-java/ch04.html">
            
                <a href="../effective-java/ch04.html">
            
                    
                    4.类和接口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../effective-java/ch05.html">
            
                <a href="../effective-java/ch05.html">
            
                    
                    5.泛型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="../effective-java/ch06.html">
            
                <a href="../effective-java/ch06.html">
            
                    
                    6.枚举和注解
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="../effective-java/ch07.html">
            
                <a href="../effective-java/ch07.html">
            
                    
                    7.方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="../effective-java/ch08.html">
            
                <a href="../effective-java/ch08.html">
            
                    
                    8.通用程序设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="../effective-java/ch09.html">
            
                <a href="../effective-java/ch09.html">
            
                    
                    9.异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="../effective-java/ch10.html">
            
                <a href="../effective-java/ch10.html">
            
                    
                    10.并发
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="../effective-java/ch11.html">
            
                <a href="../effective-java/ch11.html">
            
                    
                    11.序列化
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../head-first-design-patterns/readme.html">
            
                <a href="../head-first-design-patterns/readme.html">
            
                    
                    HeadFirst设计模式
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../head-first-design-patterns/ch01.html">
            
                <a href="../head-first-design-patterns/ch01.html">
            
                    
                    1.设计模式入门
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../head-first-design-patterns/ch02.html">
            
                <a href="../head-first-design-patterns/ch02.html">
            
                    
                    2.观察者模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../head-first-design-patterns/ch03.html">
            
                <a href="../head-first-design-patterns/ch03.html">
            
                    
                    3.装饰者模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../head-first-design-patterns/ch04.html">
            
                <a href="../head-first-design-patterns/ch04.html">
            
                    
                    4.工厂模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../head-first-design-patterns/ch05.html">
            
                <a href="../head-first-design-patterns/ch05.html">
            
                    
                    5.单件模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../head-first-design-patterns/ch06.html">
            
                <a href="../head-first-design-patterns/ch06.html">
            
                    
                    6.封装调用：命令模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../head-first-design-patterns/ch07.html">
            
                <a href="../head-first-design-patterns/ch07.html">
            
                    
                    7.适配器与外观模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="../head-first-design-patterns/ch08.html">
            
                <a href="../head-first-design-patterns/ch08.html">
            
                    
                    8.封装算法：模板方法模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="../head-first-design-patterns/ch09.html">
            
                <a href="../head-first-design-patterns/ch09.html">
            
                    
                    9.管理良好的集合：迭代器与组合模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="../head-first-design-patterns/ch10.html">
            
                <a href="../head-first-design-patterns/ch10.html">
            
                    
                    10.事务的状态：状态模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.11" data-path="../head-first-design-patterns/ch11.html">
            
                <a href="../head-first-design-patterns/ch11.html">
            
                    
                    11.控制对象访问：代理模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.12" data-path="../head-first-design-patterns/ch12.html">
            
                <a href="../head-first-design-patterns/ch12.html">
            
                    
                    12.模式中的模式：复合模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.13" data-path="../head-first-design-patterns/ch13.html">
            
                <a href="../head-first-design-patterns/ch13.html">
            
                    
                    13.真实世界中的模式：与设计模式相处
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.14" data-path="../head-first-design-patterns/ch14.html">
            
                <a href="../head-first-design-patterns/ch14.html">
            
                    
                    14.剩下的模式
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../csapp/readme.html">
            
                <a href="../csapp/readme.html">
            
                    
                    深入理解计算机系统
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../csapp/ch01.html">
            
                <a href="../csapp/ch01.html">
            
                    
                    1.计算机系统漫游
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../csapp/ch02.html">
            
                <a href="../csapp/ch02.html">
            
                    
                    2.信息的表示和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../csapp/ch03.html">
            
                <a href="../csapp/ch03.html">
            
                    
                    3.程序的机器级表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../csapp/ch04.html">
            
                <a href="../csapp/ch04.html">
            
                    
                    4.处理器体系结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../csapp/ch05.html">
            
                <a href="../csapp/ch05.html">
            
                    
                    5.优化程序性能
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../csapp/ch06.html">
            
                <a href="../csapp/ch06.html">
            
                    
                    6.存储器层次结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="../csapp/ch07.html">
            
                <a href="../csapp/ch07.html">
            
                    
                    7.链接
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" data-path="../csapp/ch08.html">
            
                <a href="../csapp/ch08.html">
            
                    
                    8.异常控制流
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.9" data-path="../csapp/ch09.html">
            
                <a href="../csapp/ch09.html">
            
                    
                    9.虚拟内存
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.10" data-path="../csapp/ch10.html">
            
                <a href="../csapp/ch10.html">
            
                    
                    10.系统级I/O
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.11" data-path="../csapp/ch11.html">
            
                <a href="../csapp/ch11.html">
            
                    
                    11.网络编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.12" data-path="../csapp/ch12.html">
            
                <a href="../csapp/ch12.html">
            
                    
                    12.并发编程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../deep-into-jvm/readme.html">
            
                <a href="../deep-into-jvm/readme.html">
            
                    
                    深入理解Java虚拟机
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../deep-into-jvm/ch01.html">
            
                <a href="../deep-into-jvm/ch01.html">
            
                    
                    1.走进Java2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../deep-into-jvm/ch02.html">
            
                <a href="../deep-into-jvm/ch02.html">
            
                    
                    2.Java内存区域与内存溢出异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../deep-into-jvm/ch03.html">
            
                <a href="../deep-into-jvm/ch03.html">
            
                    
                    3.垃圾收集器与内存分配策略
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../deep-into-jvm/ch04.html">
            
                <a href="../deep-into-jvm/ch04.html">
            
                    
                    4.虚拟机性能监控与故障处理工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="../deep-into-jvm/ch05.html">
            
                <a href="../deep-into-jvm/ch05.html">
            
                    
                    5.调优案例分析与实战
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="../deep-into-jvm/ch06.html">
            
                <a href="../deep-into-jvm/ch06.html">
            
                    
                    6.类文件结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.7" data-path="../deep-into-jvm/ch07.html">
            
                <a href="../deep-into-jvm/ch07.html">
            
                    
                    7.虚拟机类加载机制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.8" data-path="../deep-into-jvm/ch08.html">
            
                <a href="../deep-into-jvm/ch08.html">
            
                    
                    8.虚拟机字节码执行引擎
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.9" data-path="../deep-into-jvm/ch09.html">
            
                <a href="../deep-into-jvm/ch09.html">
            
                    
                    9.类加载及执行子系统的案例与实战
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.10" data-path="../deep-into-jvm/ch10.html">
            
                <a href="../deep-into-jvm/ch10.html">
            
                    
                    10.早期（编译器）优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.11" data-path="../deep-into-jvm/ch11.html">
            
                <a href="../deep-into-jvm/ch11.html">
            
                    
                    11.晚期（运行期）优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.12" data-path="../deep-into-jvm/ch12.html">
            
                <a href="../deep-into-jvm/ch12.html">
            
                    
                    12.Java内存模型与线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.13" data-path="../deep-into-jvm/ch13.html">
            
                <a href="../deep-into-jvm/ch13.html">
            
                    
                    13.线程安全与锁优化
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../explain-thread-by-picture/readme.html">
            
                <a href="../explain-thread-by-picture/readme.html">
            
                    
                    图解Java多线程设计模式
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../explain-thread-by-picture/ch01.html">
            
                <a href="../explain-thread-by-picture/ch01.html">
            
                    
                    1.序章-Java线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../explain-thread-by-picture/ch02.html">
            
                <a href="../explain-thread-by-picture/ch02.html">
            
                    
                    2.序章-多线程程序的评价标准
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../explain-thread-by-picture/ch03.html">
            
                <a href="../explain-thread-by-picture/ch03.html">
            
                    
                    3.SingleThreadedExecution模式-能通过这座桥的只有一个人
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../explain-thread-by-picture/ch04.html">
            
                <a href="../explain-thread-by-picture/ch04.html">
            
                    
                    4.Immutable模式-想破坏也破坏不了
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../explain-thread-by-picture/ch05.html">
            
                <a href="../explain-thread-by-picture/ch05.html">
            
                    
                    5.GuardedSuspension模式-等我准备好哦
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../explain-thread-by-picture/ch06.html">
            
                <a href="../explain-thread-by-picture/ch06.html">
            
                    
                    6.Balking模式-不需要就算了
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../explain-thread-by-picture/ch07.html">
            
                <a href="../explain-thread-by-picture/ch07.html">
            
                    
                    7.Producer-Consumer模式-我来做，你来用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="../explain-thread-by-picture/ch08.html">
            
                <a href="../explain-thread-by-picture/ch08.html">
            
                    
                    8.ReadWriteLock模式-大家一起读没问题，但读的时候不要写哦
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="../explain-thread-by-picture/ch09.html">
            
                <a href="../explain-thread-by-picture/ch09.html">
            
                    
                    9.Thread-Per-Message模式-这项工作就交给你了
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="../explain-thread-by-picture/ch10.html">
            
                <a href="../explain-thread-by-picture/ch10.html">
            
                    
                    10.WorkerThread模式-工作没来就一直等，工作来了就干活
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="../explain-thread-by-picture/ch11.html">
            
                <a href="../explain-thread-by-picture/ch11.html">
            
                    
                    11.Future模式-先给您提货单
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="../explain-thread-by-picture/ch12.html">
            
                <a href="../explain-thread-by-picture/ch12.html">
            
                    
                    12.Two-Phase Termination模式-先收拾房间再睡觉
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.13" data-path="../explain-thread-by-picture/ch13.html">
            
                <a href="../explain-thread-by-picture/ch13.html">
            
                    
                    13.Thread-Specific Storage模式-一个线程一个储物柜
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.14" data-path="../explain-thread-by-picture/ch14.html">
            
                <a href="../explain-thread-by-picture/ch14.html">
            
                    
                    14.Active Object模式-接收异步消息的主动对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.15" data-path="../explain-thread-by-picture/ch15.html">
            
                <a href="../explain-thread-by-picture/ch15.html">
            
                    
                    15.总结-多线程编程的模式语言
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="readme.html">
            
                <a href="readme.html">
            
                    
                    Dart编程语言
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    1.简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    2.对象、接口、类与mixin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    3.库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    4.函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    5.类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    6.表达式和语句
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    7.反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    8.异步与isolate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    9.结论
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10.10" data-path="ch10.html">
            
                <a href="ch10.html">
            
                    
                    Language Tour
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="ch11.html">
            
                <a href="ch11.html">
            
                    
                    Library Tour
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../android-framework-pouxi/readme.html">
            
                <a href="../android-framework-pouxi/readme.html">
            
                    
                    Android内核剖析
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../android-framework-pouxi/ch01.html">
            
                <a href="../android-framework-pouxi/ch01.html">
            
                    
                    1.Linux基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../android-framework-pouxi/ch02.html">
            
                <a href="../android-framework-pouxi/ch02.html">
            
                    
                    2.Java基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../android-framework-pouxi/ch03.html">
            
                <a href="../android-framework-pouxi/ch03.html">
            
                    
                    3.Android源码下载及开发环境配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="../android-framework-pouxi/ch04.html">
            
                <a href="../android-framework-pouxi/ch04.html">
            
                    
                    4.使用git
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="../android-framework-pouxi/ch05.html">
            
                <a href="../android-framework-pouxi/ch05.html">
            
                    
                    5.Binder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="../android-framework-pouxi/ch06.html">
            
                <a href="../android-framework-pouxi/ch06.html">
            
                    
                    6.Framework概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="../android-framework-pouxi/ch07.html">
            
                <a href="../android-framework-pouxi/ch07.html">
            
                    
                    7.理解Context
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.8" data-path="../android-framework-pouxi/ch08.html">
            
                <a href="../android-framework-pouxi/ch08.html">
            
                    
                    8.创建窗口的过程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.9" data-path="../android-framework-pouxi/ch09.html">
            
                <a href="../android-framework-pouxi/ch09.html">
            
                    
                    9.Framework的启动过程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.10" data-path="../android-framework-pouxi/ch10.html">
            
                <a href="../android-framework-pouxi/ch10.html">
            
                    
                    10.AMS内部原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.11" data-path="../android-framework-pouxi/ch11.html">
            
                <a href="../android-framework-pouxi/ch11.html">
            
                    
                    11.从输入设备中获取消息
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.12" data-path="../android-framework-pouxi/ch12.html">
            
                <a href="../android-framework-pouxi/ch12.html">
            
                    
                    12.屏幕绘制基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.13" data-path="../android-framework-pouxi/ch13.html">
            
                <a href="../android-framework-pouxi/ch13.html">
            
                    
                    13.View工作原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.14" data-path="../android-framework-pouxi/ch14.html">
            
                <a href="../android-framework-pouxi/ch14.html">
            
                    
                    14.WMS工作原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.15" data-path="../android-framework-pouxi/ch15.html">
            
                <a href="../android-framework-pouxi/ch15.html">
            
                    
                    15.资源访问机制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.16" data-path="../android-framework-pouxi/ch16.html">
            
                <a href="../android-framework-pouxi/ch16.html">
            
                    
                    16.程序包管理PMS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.17" data-path="../android-framework-pouxi/ch17.html">
            
                <a href="../android-framework-pouxi/ch17.html">
            
                    
                    17.输入法框架
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.18" data-path="../android-framework-pouxi/ch18.html">
            
                <a href="../android-framework-pouxi/ch18.html">
            
                    
                    18.Android编译系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.19" data-path="../android-framework-pouxi/ch19.html">
            
                <a href="../android-framework-pouxi/ch19.html">
            
                    
                    19.编译自己的ROM
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../design-patterns/readme.html">
            
                <a href="../design-patterns/readme.html">
            
                    
                    设计模式
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../design-patterns/ch01.html">
            
                <a href="../design-patterns/ch01.html">
            
                    
                    1.引言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../design-patterns/ch02.html">
            
                <a href="../design-patterns/ch02.html">
            
                    
                    2.实例研究：设计一个文档编辑器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../design-patterns/ch03.html">
            
                <a href="../design-patterns/ch03.html">
            
                    
                    3.创建型模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="../design-patterns/ch04.html">
            
                <a href="../design-patterns/ch04.html">
            
                    
                    4.结构型模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="../design-patterns/ch05.html">
            
                <a href="../design-patterns/ch05.html">
            
                    
                    5.行为模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="../design-patterns/ch06.html">
            
                <a href="../design-patterns/ch06.html">
            
                    
                    6.结论
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Language Tour</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p><a href="https://dart.dev/guides/language/language-tour" target="_blank">A tour of the Dart language</a></p>
<p>Dart 2.3 introduced the <strong>spread operator</strong> (<code>...</code>) and the <strong>null-aware spread operator</strong> (<code>...?</code>), which provide a concise way to insert multiple elements into a collection.</p>
<p>Dart 2.3 also introduced <strong>collection if</strong> and <strong>collection for</strong>, which you can use to build collections using conditionals (<code>if</code>) and repetition (<code>for</code>).</p>
<p>Although the Set <em>type</em> has always been a core part of Dart, set <em>literals</em> were introduced in Dart 2.2.</p>
<p>To create an empty set, use <code>{}</code> preceded by a type argument, or assign <code>{}</code> to a variable of type <code>Set</code>:</p>
<pre><code class="lang-dart"><span class="hljs-keyword">var</span> names = &lt;<span class="hljs-built_in">String</span>&gt;{};
<span class="hljs-comment">// Set&lt;String&gt; names = {}; // This works, too.</span>
<span class="hljs-comment">// var names = {}; // Creates a map, not a set.</span>
</code></pre>
<p> As of Dart 2, the <code>new</code> keyword is optional.</p>
<p>In Dart, runes are the UTF-32 code points of a string.Unicode defines a unique numeric value for each letter, digit, and symbol used in all of the world&#x2019;s writing systems. Because a Dart string is a sequence of UTF-16 code units, expressing 32-bit Unicode values within a string requires special syntax.</p>
<p>A <a href="https://api.dartlang.org/stable/dart-core/Symbol-class.html" target="_blank">Symbol</a> object represents an operator or identifier declared in a Dart program. You might never need to use symbols, but they&#x2019;re invaluable for APIs that refer to identifiers by name, because minification changes identifier names but not identifier symbols.To get the symbol for an identifier, use a symbol literal, which is just <code>#</code> followed by the identifier:<code>#radix</code>.Symbol literals are compile-time constants.</p>
<p>The <code>=&gt; *expr*</code> syntax is a shorthand for <code>{ return *expr*; }</code>. The <code>=&gt;</code> notation is sometimes referred to as <em>arrow</em> syntax.</p>
<p><a href="https://pub.dev/documentation/meta/latest/meta/required-constant.html" target="_blank">Required</a> is defined in the <a href="https://pub.dev/packages/meta" target="_blank">meta</a> package. Either import <code>package:meta/meta.dart</code> directly, or import another package that exports <code>meta</code>, such as Flutter&#x2019;s <code>package:flutter/material.dart</code>.</p>
<p>Old code might use a colon (<code>:</code>) instead of <code>=</code> to set default values of named parameters. The reason is that originally, only <code>:</code> was supported for named parameters. That support is likely to be deprecated, so we recommend that you <strong>use = to specify default values.</strong></p>
<p>Every app must have a top-level <code>main()</code> function, which serves as the entrypoint to the app. The <code>main()</code>function returns <code>void</code> and has an optional <code>List&lt;String&gt;</code> parameter for arguments.</p>
<p>The <code>..</code> syntax in the preceding code is called a <a href="https://dart.dev/guides/language/language-tour#cascade-notation-" target="_blank">cascade</a>. With cascades, you can perform multiple operations on the members of a single object.</p>
<p>For operators that work on two operands, the leftmost operand determines which version of the operator is used. For example, if you have a Vector object and a Point object, <code>aVector + aPoint</code> uses the Vector version of +.</p>
<pre><code class="lang-dart"><span class="hljs-comment">// Assign value to b if b is null; otherwise, b stays the same</span>
b ??= value;
</code></pre>
<pre><code class="lang-dart">expr1 ?? expr2  <span class="hljs-comment">//If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2.</span>
<span class="hljs-built_in">String</span> playerName(<span class="hljs-built_in">String</span> name) =&gt; name ?? <span class="hljs-string">&apos;Guest&apos;</span>;
</code></pre>
<p>Cascades (<code>..</code>) allow you to make a sequence of operations on the same object. In addition to function calls, you can also access fields on that same object. This often saves you the step of creating a temporary variable and allows you to write more fluid code.Strictly speaking, the &#x201C;double dot&#x201D; notation for cascades is not an operator. It&#x2019;s just part of the Dart syntax.</p>
<p>Switch statements in Dart compare integer, string, or compile-time constants using <code>==</code>. The compared objects must all be instances of the same class (and not of any of its subtypes), and the class must not override <code>==</code>.<a href="https://dart.dev/guides/language/language-tour#enumerated-types" target="_blank">Enumerated types</a> work well in <code>switch</code> statements.</p>
<p>Assert statements have no effect in production code; they&#x2019;re for development only. Flutter enables asserts in <a href="https://flutter.dev/docs/testing/debugging#debug-mode-assertions" target="_blank">debug mode.</a> Development-only tools such as <a href="https://dart.dev/tools/dartdevc" target="_blank">dartdevc</a> typically support asserts by default. Some tools, such as <a href="https://dart.dev/server/tools/dart-vm" target="_blank">dart</a> and <a href="https://dart.dev/tools/dart2js" target="_blank">dart2js,</a> support asserts through a command-line flag: <code>--enable-asserts</code>.</p>
<p>Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn&#x2019;t caught, the isolate that raised the exception is suspended, and typically the isolate and its program are terminated.</p>
<p>In contrast to Java, all of Dart&#x2019;s exceptions are unchecked exceptions. Methods do not declare which exceptions they might throw, and you are not required to catch any exceptions.</p>
<p>Dart provides <a href="https://api.dartlang.org/stable/dart-core/Exception-class.html" target="_blank">Exception</a> and <a href="https://api.dartlang.org/stable/dart-core/Error-class.html" target="_blank">Error</a> types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object&#x2014;not just Exception and Error objects - as an exception.</p>
<p>Production-quality code usually throws types that implement <a href="https://api.dartlang.org/stable/dart-core/Error-class.html" target="_blank">Error</a> or <a href="https://api.dartlang.org/stable/dart-core/Exception-class.html" target="_blank">Exception</a>.</p>
<p>To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object&#x2019;s type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:</p>
<pre><code class="lang-dart"><span class="hljs-keyword">try</span> {
  breedMoreLlamas();
} on OutOfLlamasException {
  <span class="hljs-comment">// A specific exception</span>
  buyMoreLlamas();
} on Exception <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// Anything else that is an exception</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Unknown exception: $e&apos;</span>);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// No specified type, handles all</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Something really unknown: $e&apos;</span>);
}
</code></pre>
<p>You can specify one or two parameters to <code>catch()</code>. The first is the exception that was thrown, and the second is the stack trace (a <a href="https://api.dartlang.org/stable/dart-core/StackTrace-class.html" target="_blank">StackTrace</a> object).</p>
<pre><code class="lang-dart"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// &#xB7;&#xB7;&#xB7;</span>
} on Exception <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Exception details:\n $e&apos;</span>);
} <span class="hljs-keyword">catch</span> (e, s) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Exception details:\n $e&apos;</span>);
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&apos;Stack trace:\n $s&apos;</span>);
}
</code></pre>
<p>To ensure that some code runs whether or not an exception is thrown, use a <code>finally</code> clause. If no <code>catch</code>clause matches the exception, the exception is propagated after the <code>finally</code> clause runs:</p>
<pre><code class="lang-dart"><span class="hljs-keyword">try</span> {
  breedMoreLlamas();
} <span class="hljs-keyword">finally</span> {
  <span class="hljs-comment">// Always clean up, even if an exception is thrown.</span>
  cleanLlamaStalls();
}
</code></pre>
<p>Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes descend from Object.<strong>Mixin-based inheritance</strong> means that although every class (except for Object) has exactly one superclass, a class body can be reused in multiple class hierarchies.</p>
<p>Use <code>?.</code> instead of <code>.</code> to avoid an exception when the leftmost operand is null.</p>
<p>You can create an object using a <em>constructor</em>. Constructor names can be either <code>*ClassName*</code> or<code>*ClassName*.*identifier*</code>. For example, the following code creates <code>Point</code> objects using the <code>Point()</code> and <code>Point.fromJson()</code> constructors:</p>
<pre><code class="lang-dart"><span class="hljs-keyword">var</span> p1 = Point(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> p2 = Point.fromJson({<span class="hljs-string">&apos;x&apos;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&apos;y&apos;</span>: <span class="hljs-number">2</span>});
</code></pre>
<p>Some classes provide <a href="https://dart.dev/guides/language/language-tour#constant-constructors" target="_blank">constant constructors</a>. To create a compile-time constant using a constant constructor, put the <code>const</code> keyword before the constructor name.</p>
<p>Constructing two identical compile-time constants results in a single, canonical instance:</p>
<pre><code class="lang-dart"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">const</span> ImmutablePoint(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">assert</span>(identical(a, b)); <span class="hljs-comment">// They are the same instance!</span>
</code></pre>
<p>The <code>const</code> keyword became optional within a constant context in Dart 2.</p>
<p>All instance variables generate an implicit <em>getter</em> method. Non-final instance variables also generate an implicit <em>setter</em> method. </p>
<p>If you don&#x2019;t declare a constructor, a default constructor is provided for you. The default constructor has no arguments and invokes the no-argument constructor in the superclass.</p>
<p>Subclasses don&#x2019;t inherit constructors from their superclass. A subclass that declares no constructors has only the default (no argument, no name) constructor.</p>
<p>Use a named constructor to implement multiple constructors for a class or to provide extra clarity.</p>
<pre><code class="lang-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
  <span class="hljs-built_in">num</span> x, y;

  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);

  <span class="hljs-comment">// Named constructor</span>
  Point.origin() {
    x = <span class="hljs-number">0</span>;
    y = <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>Remember that constructors are not inherited, which means that a superclass&#x2019;s named constructor is not inherited by a subclass. If you want a subclass to be created with a named constructor defined in the superclass, you must implement that constructor in the subclass.</p>
<p>By default, a constructor in a subclass calls the superclass&#x2019;s unnamed, no-argument constructor. The superclass&#x2019;s constructor is called at the beginning of the constructor body. If an <a href="https://dart.dev/guides/language/language-tour#initializer-list" target="_blank">initializer list</a> is also being used, it executes before the superclass is called. In summary, the order of execution is as follows:</p>
<ol>
<li>initializer list</li>
<li>superclass&#x2019;s no-arg constructor</li>
<li>main class&#x2019;s no-arg constructor</li>
</ol>
<p>If the superclass doesn&#x2019;t have an unnamed, no-argument constructor, then you must manually call one of the constructors in the superclass. Specify the superclass constructor after a colon (<code>:</code>), just before the constructor body (if any).Because the arguments to the superclass constructor are evaluated before invoking the constructor, an argument can be an expression such as a function call.Arguments to the superclass constructor do not have access to <code>this</code>. For example, arguments can call static methods but not instance methods.</p>
<p>Besides invoking a superclass constructor, you can also initialize instance variables before the constructor body runs. Separate initializers with commas.</p>
<p>Sometimes a constructor&#x2019;s only purpose is to redirect to another constructor in the same class. A redirecting constructor&#x2019;s body is empty, with the constructor call appearing after a colon (:).</p>
<p>If your class produces objects that never change, you can make these objects compile-time constants. To do this, define a <code>const</code> constructor and make sure that all instance variables are <code>final</code>.</p>
<p>Use the <code>factory</code> keyword when implementing a constructor that doesn&#x2019;t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype.Factory constructors have no access to <code>this</code>.</p>
<p>Invoke a factory constructor just like you would any other constructor.</p>
<p>Getters and setters are special methods that provide read and write access to an object&#x2019;s properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the <code>get</code> and <code>set</code> keywords.</p>
<p>To make a method abstract, use a semicolon (;) instead of a method body.</p>
<p>Use the <code>abstract</code> modifier to define an <em>abstract class</em>&#x2014;a class that can&#x2019;t be instantiated. Abstract classes are useful for defining interfaces, often with some implementation. If you want your abstract class to appear to be instantiable, define a <a href="https://dart.dev/guides/language/language-tour#factory-constructors" target="_blank">factory constructor</a>.</p>
<p>Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B&#x2019;s API without inheriting B&#x2019;s implementation, class A should implement the B interface.</p>
<p>A class implements one or more interfaces by declaring them in an <code>implements</code> clause and then providing the APIs required by the interfaces.</p>
<p>Use <code>extends</code> to create a subclass, and <code>super</code> to refer to the superclass.</p>
<p>Subclasses can override instance methods, getters, and setters. You can use the <code>@override</code> annotation to indicate that you are intentionally overriding a member.To narrow the type of a method parameter or instance variable in code that is <a href="https://dart.dev/guides/language/sound-dart" target="_blank">type safe</a>, you can use the <a href="https://dart.dev/guides/language/sound-problems#the-covariant-keyword" target="_blank"><code>covariant</code> keyword</a>.</p>
<p>You can override the operators shown in the following table. For example, if you define a Vector class, you might define a <code>+</code> method to add two vectors.</p>
<table>
<thead>
<tr>
<th><code>&lt;</code></th>
<th><code>+</code></th>
<th>`</th>
<th>`</th>
<th><code>[]</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td><code>/</code></td>
<td><code>^</code></td>
<td><code>[]=</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>~/</code></td>
<td><code>&amp;</code></td>
<td><code>~</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>*</code></td>
<td><code>&lt;&lt;</code></td>
<td><code>==</code></td>
</tr>
<tr>
<td><code>&#x2013;</code></td>
<td><code>%</code></td>
<td><code>&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<p>If you override <code>==</code>, you should also override Object&#x2019;s <code>hashCode</code> getter. </p>
<p>Enumerated types, often called <em>enumerations</em> or <em>enums</em>, are a special kind of class used to represent a fixed number of constant values.</p>
<p>Each value in an enum has an <code>index</code> getter, which returns the zero-based position of the value in the enum declaration. To get a list of all of the values in the enum, use the enum&#x2019;s <code>values</code> constant.</p>
<p>Enumerated types have the following limits:</p>
<ul>
<li>You can&#x2019;t subclass, mix in, or implement an enum.</li>
<li>You can&#x2019;t explicitly instantiate an enum.</li>
</ul>
<p>Mixins are a way of reusing a class&#x2019;s code in multiple class hierarchies.</p>
<p>To <em>use</em> a mixin, use the <code>with</code> keyword followed by one or more mixin names.</p>
<p>To <em>implement</em> a mixin, create a class that extends Object and declares no constructors. Unless you want your mixin to be usable as a regular class, use the <code>mixin</code> keyword instead of <code>class</code>.To specify that only certain types can use the mixin &#x2014; for example, so your mixin can invoke a method that it doesn&#x2019;t define &#x2014; use <code>on</code> to specify the required superclass.Support for the <code>mixin</code> keyword was introduced in Dart 2.1. Code in earlier releases usually used <code>abstract class</code> instead. </p>
<p>Use the <code>static</code> keyword to implement class-wide variables and methods.Static variables (class variables) are useful for class-wide state and constants.Static variables aren&#x2019;t initialized until they&#x2019;re used.</p>
<p>Consider using top-level functions, instead of static methods, for common or widely used utilities and functionality.</p>
<p>The &lt;&#x2026;&gt; notation marks List as a <em>generic</em> (or <em>parameterized</em>) type&#x2014;a type that has formal type parameters. <a href="https://dart.dev/guides/language/effective-dart/design#do-follow-existing-mnemonic-conventions-when-naming-type-parameters" target="_blank">By convention</a>, most type variables have single-letter names, such as E, T, S, K, and V.</p>
<p>Dart generic types are <em>reified</em>, which means that they carry their type information around at runtime.In contrast, generics in Java use <em>erasure</em>, which means that generic type parameters are removed at runtime. In Java, you can test whether an object is a List, but you can&#x2019;t test whether it&#x2019;s a <code>List&lt;String&gt;</code>.</p>
<p>When implementing a generic type, you might want to limit the types of its parameters. You can do this using <code>extends</code>.</p>
<p>Initially, Dart&#x2019;s generic support was limited to classes. A newer syntax, called <em>generic methods</em>, allows type arguments on methods and functions.</p>
<p>The <code>import</code> and <code>library</code> directives can help you create a modular and shareable code base. Libraries not only provide APIs, but are a unit of privacy: identifiers that start with an underscore (_) are visible only inside the library. <em>Every Dart app is a library</em>, even if it doesn&#x2019;t use a <code>library</code> directive.</p>
<p>Libraries can be distributed using <a href="https://dart.dev/guides/packages" target="_blank">packages</a>.</p>
<p>The only required argument to <code>import</code> is a URI specifying the library. For built-in libraries, the URI has the special <code>dart:</code> scheme. For other libraries, you can use a file system path or the <code>package:</code> scheme. The <code>package:</code> scheme specifies libraries provided by a package manager such as the pub tool. <em>URI</em> stands for uniform resource identifier. <em>URLs</em> (uniform resource locators) are a common kind of URI.</p>
<p><em>Deferred loading</em> (also called <em>lazy loading</em>) allows an application to load a library on demand, if and when it&#x2019;s needed. Here are some cases when you might use deferred loading:</p>
<ul>
<li>To reduce an app&#x2019;s initial startup time.</li>
<li>To perform A/B testing&#x2014;trying out alternative implementations of an algorithm, for example.</li>
<li>To load rarely used functionality, such as optional screens and dialogs.</li>
</ul>
<p>To lazily load a library, you must first import it using <code>deferred as</code>.</p>
<p>When you need the library, invoke <code>loadLibrary()</code> using the library&#x2019;s identifier.</p>
<p>You can invoke <code>loadLibrary()</code> multiple times on a library without problems. The library is loaded only once.</p>
<p>Keep in mind the following when you use deferred loading:</p>
<ul>
<li>A deferred library&#x2019;s constants aren&#x2019;t constants in the importing file. Remember, these constants don&#x2019;t exist until the deferred library is loaded.</li>
<li>You can&#x2019;t use types from a deferred library in the importing file. Instead, consider moving interface types to a library imported by both the deferred library and the importing file.</li>
<li>Dart implicitly inserts <code>loadLibrary()</code> into the namespace that you define using <code>deferred as*namespace*</code>. The <code>loadLibrary()</code> function returns a <a href="https://dart.dev/guides/libraries/library-tour#future" target="_blank">Future</a>.</li>
</ul>
<p>The Dart VM allows access to members of deferred libraries even before the call to <code>loadLibrary()</code>. This behavior might change, so <strong>don&#x2019;t depend on the current VM behavior.</strong></p>
<p>Dart libraries are full of functions that return <a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank">Future</a> or <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank">Stream</a> objects. These functions are <em>asynchronous</em>: they return after setting up a possibly time-consuming operation (such as I/O), without waiting for that operation to complete.</p>
<p>Although an async function might perform time-consuming operations, it doesn&#x2019;t wait for those operations. Instead, the async function executes only until it encounters its first <code>await</code>expression (<a href="https://github.com/dart-lang/sdk/blob/master/docs/newsletter/20170915.md#synchronous-async-start" target="_blank">details</a>). Then it returns a Future object, resuming execution only after the <code>await</code>expression completes.</p>
<p>In <code>await *expression*</code>, the value of <code>*expression*</code> is usually a Future; if it isn&#x2019;t, then the value is automatically wrapped in a Future. This Future object indicates a promise to return an object. The value of <code>await*expression*</code> is that returned object. The await expression makes execution pause until that object is available.</p>
<p>An <em>async function</em> is a function whose body is marked with the <code>async</code> modifier.</p>
<p>Note that the function&#x2019;s body doesn&#x2019;t need to use the Future API. Dart creates the Future object if necessary.</p>
<p>If your function doesn&#x2019;t return a useful value, make its return type <code>Future&lt;void&gt;</code>.</p>
<p>When you need to get values from a Stream, you have two options:</p>
<ul>
<li>Use <code>async</code> and an <em>asynchronous for loop</em> (<code>await for</code>).</li>
<li>Use the Stream API, as described <a href="https://dart.dev/guides/libraries/library-tour#stream" target="_blank">in the library tour</a>.</li>
</ul>
<p>When you need to lazily produce a sequence of values, consider using a <em>generator function</em>. Dart has built-in support for two kinds of generator functions:</p>
<ul>
<li><strong>Synchronous</strong> generator: Returns an <strong>Iterable</strong> object.</li>
<li><strong>Asynchronous</strong> generator: Returns a <strong>Stream</strong> object.</li>
</ul>
<p>To implement a <strong>synchronous</strong> generator function, mark the function body as <code>sync*</code>, and use <code>yield</code>statements to deliver values:</p>
<pre><code class="lang-dart"><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* {
  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;
}
</code></pre>
<p>To implement an <strong>asynchronous</strong> generator function, mark the function body as <code>async*</code>, and use <code>yield</code>statements to deliver values:</p>
<pre><code class="lang-dart">Stream&lt;<span class="hljs-built_in">int</span>&gt; asynchronousNaturalsTo(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">async</span>* {
  <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (k &lt; n) <span class="hljs-keyword">yield</span> k++;
}
</code></pre>
<p>If your generator is recursive, you can improve its performance by using <code>yield*</code>:</p>
<pre><code class="lang-dart"><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; naturalsDownFrom(<span class="hljs-built_in">int</span> n) <span class="hljs-keyword">sync</span>* {
  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">yield</span> n;
    <span class="hljs-keyword">yield</span>* naturalsDownFrom(n - <span class="hljs-number">1</span>);
  }
}
</code></pre>
<p>To allow an instance of your Dart class to be called like a function, implement the <code>call()</code> method.</p>
<p>Most computers, even on mobile platforms, have multi-core CPUs. To take advantage of all those cores, developers traditionally use shared-memory threads running concurrently. However, shared-state concurrency is error prone and can lead to complicated code.</p>
<p>Instead of threads, all Dart code runs inside of <em>isolates</em>. Each isolate has its own memory heap, ensuring that no isolate&#x2019;s state is accessible from any other isolate.</p>
<p>In Dart, functions are objects, just like strings and numbers are objects. A <em>typedef</em>, or <em>function-type alias</em>, gives a function type a name that you can use when declaring fields and return types. A typedef retains type information when a function type is assigned to a variable.</p>
<pre><code class="lang-dart"><span class="hljs-keyword">typedef</span> Compare = <span class="hljs-built_in">int</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedCollection</span> </span>{
  Compare compare;

  SortedCollection(<span class="hljs-keyword">this</span>.compare);
}

<span class="hljs-comment">// Initial, broken implementation.</span>
<span class="hljs-built_in">int</span> sort(<span class="hljs-built_in">Object</span> a, <span class="hljs-built_in">Object</span> b) =&gt; <span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span> main() {
  SortedCollection coll = SortedCollection(sort);
  <span class="hljs-keyword">assert</span>(coll.compare <span class="hljs-keyword">is</span> <span class="hljs-built_in">Function</span>);
  <span class="hljs-keyword">assert</span>(coll.compare <span class="hljs-keyword">is</span> Compare);
}
</code></pre>
<p>Metadata can appear before a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive. You can retrieve metadata at runtime using reflection.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch09.html" class="navigation navigation-prev " aria-label="Previous page: 9.结论">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch11.html" class="navigation navigation-next " aria-label="Next page: Library Tour">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Language Tour","level":"1.10.10","depth":2,"next":{"title":"Library Tour","level":"1.10.11","depth":2,"path":"the-dart-programming-language/ch11.md","ref":"the-dart-programming-language/ch11.md","articles":[]},"previous":{"title":"9.结论","level":"1.10.9","depth":2,"path":"the-dart-programming-language/ch09.md","ref":"the-dart-programming-language/ch09.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"the-dart-programming-language/ch10.md","mtime":"2019-05-29T09:41:33.789Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-08-28T15:25:11.346Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

